---
id: 4-find-median-sorted-arrays
title: 寻找两个正序数组的中位数
sidebar_label: 4. 寻找两个正序数组的中位数
keywords:
  - 二分查找
---

:::success Tips
题目类型: 二分查找
:::

## 题目

给定两个大小分别为 `m` 和 `n` 的正序数组 `nums1` 和 `nums2`. 请你找出并返回这两个正序数组的**中位数**.

:::info 示例

```ts
输入: nums1 = [1, 3], nums2 = [2]
输出: 2
解释: 合并后的数组 = [1, 2, 3], 中位数 2
```

```ts
输入: nums1 = [1, 2], nums2 = [3, 4]
输出: 2.50000
解释: 合并数组 = [1, 2, 3, 4], 中位数 (2 + 3) / 2 = 2.5
```

:::

## 题解

import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

<Tabs>
  <TabItem value="JavaScript - 朴素解法" label="JavaScript - 朴素解法">

最朴素的解法是将两个数组按照从小到大 merge 到一起, 然后取中值. 具体看代码注释.

```ts
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 */
var findMedianSortedArrays = function (nums1, nums2) {
  const m = nums1.length
  const n = nums2.length
  let total = m + n
  let isOdd = true

  if (total % 2 === 0) {
    isOdd = false
  }
  total = (total / 2) | 0

  const arr = []

  let i = 0,
    j = 0

  while (i + j <= total) {
    // 如果 i 已经走到头了, 需要把 nums2 剩下的元素放到 arr 最后
    if (i === m) {
      arr.push(...nums2.slice(j))
      break
    }
    //  如果 j 已经走到头了, 需要把 nums1 剩下的元素放到 arr 最后
    if (j === n) {
      arr.push(...nums1.slice(i))
      break
    }
    if (nums1[i] < nums2[j]) {
      arr.push(nums1[i++])
    } else {
      arr.push(nums2[j++])
    }
  }

  return isOdd ? arr[total] : (arr[total] + arr[total - 1]) / 2
}
```

- 时间复杂度: `O(m + n)`
- 空间复杂度: `O(m + n)`

</TabItem>
<TabItem value="JavaScript - 二分查找" label="JavaScript - 二分查找" default>

```ts
var findMedianSortedArrays = function (nums1, nums2) {
  let len1 = nums1.length
  let len2 = nums2.length
  let left = Math.floor((len1 + len2 + 1) / 2)
  let right = Math.floor((len1 + len2 + 2) / 2)
  return (
    (findkth(nums1, 0, len1 - 1, nums2, 0, len2 - 1, left) +
      findkth(nums1, 0, len1 - 1, nums2, 0, len2 - 1, right)) /
    2
  )
}

var findkth = function (arr1, start1, end1, arr2, start2, end2, k) {
  let n = end1 - start1 + 1
  let m = end2 - start2 + 1

  if (n > m) return findkth(arr2, start2, end2, arr1, start1, end1, k)
  if (n === 0) return arr2[start2 + k - 1]
  if (k === 1) return Math.min(arr1[start1], arr2[start2])

  let i = start1 + Math.min(n, Math.floor(k / 2)) - 1
  let j = start2 + Math.min(m, Math.floor(k / 2)) - 1

  if (arr1[i] > arr2[j]) {
    return findkth(arr1, start1, end1, arr2, j + 1, end2, k - (j - start2 + 1))
  } else {
    return findkth(arr1, i + 1, end1, arr2, start2, end2, k - (i - start1 + 1))
  }
}
```

- 时间复杂度: `O(log(m + n))`
- 空间复杂度: `O(1)`, 虽然用到了递归, 但属于尾递归优化.

</TabItem>
<TabItem value="Rust" label="Rust">

```rust
pub fn find_median_sorted_arrays(nums1: Vec<i32>, nums2: Vec<i32>) -> f64 {
    let (m, n) = (nums1.len(), nums2.len());
    let mut is_odd = true;
    let mut total = m + n;

    if total % 2 == 0 {
        is_odd = false;
    }

    total /= 2;

    let mut arr = vec![];

    let (mut i, mut j) = (0, 0);

    while i + j <= total {
        if i == m {
            arr.append(&mut nums2[j..].to_vec());
            break;
        }

        if j == n {
            arr.append(&mut nums1[i..].to_vec());
            break;
        }

        if nums1[i] < nums2[j] {
            arr.push(nums1[i]);
            i += 1;
        } else {
            arr.push(nums2[j]);
            j += 1;
        }
    }

    if is_odd {
        arr[total] as f64
    } else {
        (arr[total] + arr[total - 1]) as f64 / 2.0
    }
}
```

</TabItem>
</Tabs>
