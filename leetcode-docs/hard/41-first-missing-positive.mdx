---
id: 41-first-missing-positive
title: 缺失的第一个正数
sidebar_label: 41. 缺失的第一个正数
---

## 题目

给你一个未排序的整数数组 `nums`, 请你找出其中没有出现的最小的正整数.

:::info 示例

```ts
输入: nums = [1, 2, 0]
输出: 3
```

```ts
输入: nums = [3, 4, -1, 1]
输出: 2
```

```ts
输入: nums = [7, 8, 9, 11, 12]
输出: 1
```

:::

## 题解

思路是使用原地哈希, 即使用数字下标作为哈希.

import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

<Tabs>
  <TabItem value="JavaScript - 朴素解法" label="JavaScript - 朴素解法">

```ts
/**
 * @param {number[]} nums
 * @return {number}
 */
var firstMissingPositive = function (nums) {
  const n = nums.length

  for (let i = 0; i < n; i++) {
    while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] !== nums[i]) {
      // 满足在指定范围内, 并且没有放在正确的位置上, 才交换
      // 例如: 数值 3 应该放在索引 2 的位置上
      ;[nums[nums[i] - 1], nums[i]] = [nums[i], nums[nums[i] - 1]]
    }
  }

  // [1, -1, 3, 4]
  for (let i = 0; i < n; i++) {
    if (nums[i] !== i + 1) {
      return i + 1
    }
  }
  // 都正确则返回数组长度 + 1
  return n + 1
}
```

</TabItem>
<TabItem value="Rust" label="Rust">

```rust
pub fn first_missing_positive(nums: Vec<i32>) -> i32 {
    let mut nums = nums;
    let n = nums.len();

    for i in 0..n {
        while nums[i] > 0 && nums[i] <= (n as i32) && nums[(nums[i] - 1) as usize] != nums[i] {
            let j = (nums[i] - 1) as usize;
            nums.swap(i, j);
        }
    }

    for i in 0..n {
        if nums[i] != i as i32 + 1 {
            return i as i32 + 1;
        }
    }

    n as i32 + 1
}
```

</TabItem>
</Tabs>
