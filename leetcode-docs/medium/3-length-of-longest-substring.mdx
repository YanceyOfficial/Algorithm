---
id: 3-length-of-longest-substring
title: 无重复字符的最长子串
sidebar_label: 3. 无重复字符的最长子串
keywords:
  - Sliding Window
---

:::success Tips
题目类型: Sliding Window

相关题目:

- [76. 最小覆盖子串](/leetcode/hard/76-min-window)
- [209. 长度最小的子数组](/leetcode/medium/209-min-sub-array-len)
- [239. 滑动窗口最大值](/leetcode/hard/239-max-sliding-window)
- [424. 替换后的最长重复字符](/leetcode/medium/424-character-replacement)
- [438. 找到字符串中所有字母异位词](/leetcode/medium/438-find-anagrams)
- [567. 字符串的排列](/leetcode/medium/567-check-inclusion)

:::

## 题目

给定一个字符串, 找出其中不含有重复字符的**最长子串**的长度.

:::info 示例

```ts
输入: s = "bacabcbb"

输出: 3

解释: 因为无重复字符的最长子串是 "abc", 所以其长度为 3.
```

```ts
输入: s = "pwwkew"

输出: 3

解释: 因为无重复字符的最长子串是 "wke", 所以其长度为 3.
```

:::

## 题解

import Carousel from 'nuka-carousel'
import { randomSeries } from 'yancey-js-util'
import useBaseUrl from '@docusaurus/useBaseUrl'

<Carousel
  style={{ margin: '48px 0', border: '1px solid #ccc' }}
  renderBottomCenterControls={null}
>
  {new Array(10).fill(randomSeries(6)).map((val, index) => (
    <img
      key={val}
      src={useBaseUrl(`/img/3-length-of-longest-substring-${index + 1}.png`)}
    />
  ))}
</Carousel>

import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

<Tabs>
  <TabItem value="JavaScript" label="JavaScript" default>

```ts
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function (s) {
  const n = s.length
  const map = new Map()
  let start = 0
  let end = 0
  let max = 0

  while (end < n) {
    const endLetter = s[end++]

    if (map.has(endLetter)) {
      map.set(endLetter, map.get(endLetter) + 1)
    } else {
      map.set(endLetter, 1)
    }

    while (map.get(endLetter) > 1) {
      const startLetter = s[start++]
      map.set(startLetter, map.get(startLetter) - 1)
    }

    max = Math.max(max, end - start)
  }

  return max
}
```

</TabItem>

<TabItem value="Rust" label="Rust">

```rust
use std::{cmp, collections::HashMap};

pub fn length_of_longest_substring(s: String) -> i32 {
    let s_bytes = s.as_bytes();
    let mut max_len = 0;
    let mut map: HashMap<u8, i32> = HashMap::with_capacity(26);
    let mut start = 0;
    let mut end = 0;

    while end < s.len() {
        let end_letter = s_bytes[end];
        end += 1;
        map.entry(end_letter).and_modify(|e| *e += 1).or_insert(1);

        // while map.get(&end_letter).unwrap() > &1 {
        // while map.get(&end_letter) > Some(&1) {
        while map[&end_letter] > 1 {
            let start_letter = s_bytes[start];
            start += 1;
            map.entry(start_letter).and_modify(|e| *e -= 1);
        }

        max_len = cmp::max(end - start, max_len);
    }

    max_len as i32
}

```

</TabItem>
</Tabs>

## 复杂度分析

- 时间复杂度: O(n)
- 空间复杂度: O(n)
