---
id: 22-genertate-parenthesis
title: 括号生成
sidebar_label: 22. 括号生成
keywords:
  - backtrack
---

:::success Tips
题目类型: backtrack
:::

## 题目

给出 n 代表生成括号的对数, 请你写出一个函数, 使其能够生成所有可能的并且有效的括号组合.

:::info 示例

输入: 3

输出:

```ts
;['((()))', '(()())', '(())()', '()(())', '()()()']
```

:::

## 题解

import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

<Tabs>
  <TabItem value="JavaScript" label="JavaScript" default>

```ts
/**
 * @param {number} n
 * @return {string[]}
 */
var generateParenthesis = function (n) {
  const res = []

  const backtrack = (left, right, track) => {
    // 对于每个 track 子串, 都要保证 left >= right. 
    // 比如 (() (), 都是左括号的数量大于或等于右括号的数量
    // 即对于剩下的括号数量, 一定是 left <= right, 所以如果出现了 right < left, 一定不符合
    if (right < left) return

    // 假设 left 小于 0 了, 意味着 left 的数量大于 n 了, 一定不符合
    if (left < 0 || right < 0) return

    // 当两边括号都恰好为 0 了, 证明是一个合法的括号生成
    if (left === 0 && right === 0) {
      res.push(track.join(''))
      return
    }

    track.push('(')
    backtrack(left - 1, right, track)
    track.pop()

    track.push(')')
    backtrack(left, right - 1, track)
    track.pop()
  }

  backtrack(n, n, [])

  return res
}
```

</TabItem>
<TabItem value="Rust" label="Rust">

```rust
pub fn generate_parenthesis(n: i32) -> Vec<String> {
    let mut res: Vec<String> = vec![];
    backtrack(n, n, &mut vec![], &mut res);
    res
}

fn backtrack(left: i32, right: i32, track: &mut Vec<String>, res: &mut Vec<String>) {
    if right < left {
        return;
    }

    if left < 0 || right < 0 {
        return;
    }

    if left == 0 && right == 0 {
        res.push(track.join(""));
        return;
    }

    track.push("(".to_string());
    backtrack(left - 1, right, track, res);
    track.pop();

    track.push(")".to_string());
    backtrack(left, right - 1, track, res);
    track.pop();
}
```

</TabItem>
</Tabs>
