---
id: 77-combine
title: 组合
sidebar_label: 77. 组合
keywords:
  - BackTracking
---

:::success Tips
题目类型: BackTracking
:::

## 题目

给定两个整数 n 和 k, 返回 1 ... n 中所有可能的 k 个数的组合.

:::info 示例

输入: `n = 4, k = 2`

输出: `[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4] ]`
:::

## 题解

好了我已经吐了, 这个题其实是 [40. 组合总数 II](/leetcode/medium/40-combination-sum) 的变体. 翻译过来就是: 候选项为 [1, n], 每个组合有 k 个数, 每个数字只能选一次, 且组合不能重复(即 [1, 2] 和 [2, 1] 视为同一个).

import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

<Tabs>
  <TabItem value="JavaScript" label="JavaScript" default>

```js
/**
 * @param {number} n
 * @param {number} k
 * @return {number[][]}
 */
var combine = function (n, k) {
  const res = []

  const backtracking = function (begin, track) {
    if (track.length === k) {
      res.push(track)
      return
    }

    for (let i = begin; i <= n; i++) {
      if (!track.includes(i)) {
        track.push(i)
        backtracking(i, track.slice())
        track.pop()
      }
    }
  }

  backtracking(1, [])
  return res
}
```

</TabItem>
<TabItem value="Rust" label="Rust">

```rust
pub fn subsets(nums: Vec<i32>) -> Vec<Vec<i32>> {
    let mut res: Vec<Vec<i32>> = vec![];
    backtracking(0, &nums, &mut vec![], &mut res);
    res
}

fn backtracking(begin: usize, nums: &Vec<i32>, track: &mut Vec<i32>, res: &mut Vec<Vec<i32>>) {
    res.push(track.to_vec());

    for i in begin..nums.len() {
        track.push(nums[i]);
        backtracking(i + 1, nums, track, res);
        track.pop();
    }
}
```

</TabItem>
</Tabs>
